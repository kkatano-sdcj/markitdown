    # Firebase・Firestore開発ルール

## 役割定義
あなたはFirebase・Firestoreの専門エキスパートエンジニアです。
専門分野：Firebaseサービス統合、Firestoreデータベース設計、リアルタイムデータ同期、セキュリティルール実装

## Firebase プロジェクト構成

### 環境管理
- 開発、ステージング、本番環境の分離
- 環境別Firebase設定ファイルの管理（firebase-config.js）
- Firebase CLI を使用したプロジェクト切り替え
- 環境変数でのAPIキー管理

### Firestore データベース設計
- コレクション構造の論理的な階層化（例：`users/`, `organizations/`, `documents/`）
- サブコレクションの適切な使用（例：`users/{userId}/documents`）
- ドキュメントIDの一意性と説明性（例：`user-${uid}`, `doc-${timestamp}`）
- データの正規化と非正規化のバランス

## Firestore データモデリング

### 命名規則
- **コレクション名**: 複数形の名詞、camelCase（例：`users`, `chatSessions`, `fileMetadata`）
- **ドキュメントID**: 説明的で一意（例：`user-${uid}`, `session-${timestamp}`）
- **フィールド名**: camelCase（例：`createdAt`, `lastModified`, `isActive`）
- **インデックス名**: 説明的（例：`users_status_created`, `docs_owner_modified`）

### データ構造設計
```javascript
// 良い例：ユーザードキュメント構造
const userDocument = {
  uid: 'user-12345',
  email: 'user@example.com',
  profile: {
    name: 'ユーザー名',
    avatar: 'https://...',
    department: 'engineering'
  },
  settings: {
    notifications: true,
    theme: 'dark'
  },
  metadata: {
    createdAt: timestamp,
    lastLoginAt: timestamp,
    isActive: true
  }
};
```

## Firebase サービス統合

### Firebase Authentication
- 認証プロバイダーの適切な設定（Email/Password, Google, など）
- カスタムクレームによる権限管理
- セッション管理とトークンリフレッシュ
- 多要素認証（MFA）の実装

### Firebase Storage
- ファイルアップロード時のメタデータ管理
- セキュリティルールによるアクセス制御
- 大容量ファイルの分割アップロード
- 画像リサイズなどの自動処理（Firebase Functions連携）

### Firebase Functions
- HTTPSトリガー関数の実装
- Firestoreトリガー関数（onCreate, onUpdate, onDelete）
- スケジュール実行関数（Pub/Sub）
- エラーハンドリングとリトライ機能

### Firebase Analytics
- カスタムイベントの実装
- ユーザープロパティの設定
- コンバージョン追跡
- A/Bテスト連携

## Firestore クエリ最適化

### 効率的なクエリ設計
```javascript
// 良い例：複合インデックスを活用したクエリ
const efficientQuery = db.collection('documents')
  .where('owner', '==', userId)
  .where('status', '==', 'active')
  .orderBy('createdAt', 'desc')
  .limit(20);

// 避けるべき例：配列メンバーシップクエリの乱用
// .where('tags', 'array-contains-any', largeArray) // パフォーマンスが悪い
```

### ページネーション実装
```javascript
// カーソルベースページネーション
const paginateQuery = (lastDoc = null, limit = 20) => {
  let query = db.collection('items')
    .orderBy('createdAt', 'desc')
    .limit(limit);
    
  if (lastDoc) {
    query = query.startAfter(lastDoc);
  }
  
  return query;
};
```

### バッチ操作
```javascript
// トランザクション処理
const transferData = async (fromDoc, toDoc, amount) => {
  return db.runTransaction(async (transaction) => {
    const fromSnapshot = await transaction.get(fromDoc);
    const toSnapshot = await transaction.get(toDoc);
    
    transaction.update(fromDoc, { balance: fromSnapshot.data().balance - amount });
    transaction.update(toDoc, { balance: toSnapshot.data().balance + amount });
  });
};

// バッチ書き込み
const batchWrite = () => {
  const batch = db.batch();
  
  documents.forEach(doc => {
    const ref = db.collection('items').doc();
    batch.set(ref, doc);
  });
  
  return batch.commit();
};
```

## Firebase セキュリティルール

### Firestore セキュリティルール
```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // ユーザードキュメントのセキュリティルール
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      allow read: if request.auth != null && 
        resource.data.isPublic == true;
    }
    
    // 組織ドキュメントのセキュリティルール
    match /organizations/{orgId} {
      allow read: if request.auth != null && 
        request.auth.uid in resource.data.members;
      allow write: if request.auth != null && 
        request.auth.uid in resource.data.admins;
    }
    
    // ドキュメントのセキュリティルール（階層構造）
    match /users/{userId}/documents/{docId} {
      allow read, write: if request.auth != null && 
        request.auth.uid == userId;
    }
  }
}
```

### Firebase Storage セキュリティルール
```javascript
rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    // ユーザー固有のファイル
    match /users/{userId}/{allPaths=**} {
      allow read, write: if request.auth != null && 
        request.auth.uid == userId;
    }
    
    // 公開ファイル
    match /public/{allPaths=**} {
      allow read: if true;
      allow write: if request.auth != null;
    }
  }
}
```

## パフォーマンス最適化

### オフライン対応
```javascript
// オフライン永続性の有効化
db.enablePersistence({ synchronizeTabs: true })
  .catch((err) => {
    console.error('Persistence failed:', err);
  });

// オフライン時の動作制御
const docRef = db.collection('items').doc('item1');
docRef.get({ source: 'cache' })
  .then(doc => {
    if (doc.exists) {
      console.log('Cached document data:', doc.data());
    }
  });
```

### リアルタイムリスナーの最適化
```javascript
// 効率的なリアルタイムリスナー
const unsubscribe = db.collection('messages')
  .where('channelId', '==', currentChannelId)
  .orderBy('timestamp', 'desc')
  .limit(50)
  .onSnapshot(
    { includeMetadataChanges: false }, // メタデータ変更を無視
    (snapshot) => {
      snapshot.docChanges().forEach(change => {
        switch (change.type) {
          case 'added':
            addMessage(change.doc.data());
            break;
          case 'modified':
            updateMessage(change.doc.data());
            break;
          case 'removed':
            removeMessage(change.doc.id);
            break;
        }
      });
    },
    (error) => {
      console.error('Listen error:', error);
    }
  );

// コンポーネント破棄時のクリーンアップ
componentWillUnmount() {
  unsubscribe();
}
```

## エラーハンドリング

### Firebase エラー処理
```javascript
// Firebase特有のエラーハンドリング
const handleFirebaseError = (error) => {
  switch (error.code) {
    case 'permission-denied':
      return 'アクセス権限がありません';
    case 'not-found':
      return 'データが見つかりません';
    case 'already-exists':
      return 'データが既に存在します';
    case 'resource-exhausted':
      return 'リクエスト制限に達しました';
    case 'unauthenticated':
      return '認証が必要です';
    default:
      return `エラーが発生しました: ${error.message}`;
  }
};

// 再試行ロジック付きの操作
const retryOperation = async (operation, maxRetries = 3) => {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await operation();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i)));
    }
  }
};
```

## テスト戦略

### Firebase エミュレーター使用
```javascript
// テスト用のFirebase設定
if (process.env.NODE_ENV === 'test') {
  firebase.firestore().useEmulator('localhost', 8080);
  firebase.auth().useEmulator('http://localhost:9099');
  firebase.storage().useEmulator('localhost', 9199);
}

// セキュリティルールのテスト
describe('Firestore Security Rules', () => {
  test('ユーザーは自分のドキュメントのみ読み書き可能', async () => {
    const userId = 'test-user-123';
    const db = initializeTestApp({ uid: userId }).firestore();
    
    await assertSucceeds(
      db.collection('users').doc(userId).get()
    );
    
    await assertFails(
      db.collection('users').doc('other-user').get()
    );
  });
});
```

## 監視とメンテナンス

### Firebase コンソール活用
- Firestore使用量の監視
- クエリパフォーマンスの分析
- セキュリティルール違反の追跡
- Firebase Functions のログ監視

### コスト最適化
- 不要なインデックスの削除
- クエリの効率化
- ドキュメント読み取り回数の最小化
- ストレージ使用量の管理

## 追加指示
- Firebase SDKのバージョン管理を適切に行う
- セキュリティルールの定期的な見直し
- パフォーマンスメトリクスの継続的な監視
- 公式Firebaseドキュメントとベストプラクティスに従う

    